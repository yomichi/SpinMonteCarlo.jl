var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internal-APIs","page":"Internals","title":"Internal APIs","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation for SpinMonteCarlo.jl's internals (not exported).","category":"page"},{"location":"lib/internals/#Driver","page":"Internals","title":"Driver","text":"","category":"section"},{"location":"lib/internals/#SpinMonteCarlo.accumulateObservables!","page":"Internals","title":"SpinMonteCarlo.accumulateObservables!","text":"accumulateObservables!(model, obs::MCObservableSet, localobs::Dict)\n\nAccumulates localobs into obs. For example, obs[\"Energy\"] << localobs[\"Energy\"].\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.postproc","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::Model, param::Parameter, obs::MCObservableSet)\n\nPost process of observables. For example, Specific heat will be calculated from energy, energy^2, and temperature.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{Ising, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::Ising, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, m is total magnetization per site and epsilon is total energy per site.\n\n\"Binder Ratio\"\nR = fracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility\"\nchi = fracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{Potts, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::Potts, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, m is total magnetization per site and epsilon is total energy per site.\n\n\"Binder Ratio\"\nR = fracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility\"\nchi = fracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{Clock, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::Clock, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, m is total magnetization per site and epsilon is total energy per site.\n\n\"Binder Ratio x\"\nfracleft langle m_x^4 right rangleleft langle m_x^2 rightrangle^2\n\"Binder Ratio y\"\nfracleft langle m_y^4 right rangleleft langle m_y^2 rightrangle^2\n\"Binder Ratio\"\nfracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility x\"\nfracNTleft(leftlangle m_x^2rightrangleright)\n\"Susceptibility y\"\nfracNTleft(leftlangle m_y^2rightrangleright)\n\"Susceptibility y\"\nfracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility x\"\nfracNTleft(leftlangle m_x^2rightrangle - leftlangle m_x rightrangle^2right)\n\"Connected Susceptibility y\"\nfracNTleft(leftlangle m_y^2rightrangle - leftlangle m_y rightrangle^2right)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{XY, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::XY, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, m is total magnetization per site and epsilon is total energy per site.\n\n\"Binder Ratio x\"\nfracleft langle m_x^4 right rangleleft langle m_x^2 rightrangle^2\n\"Binder Ratio y\"\nfracleft langle m_y^4 right rangleleft langle m_y^2 rightrangle^2\n\"Binder Ratio\"\nfracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility x\"\nfracNTleft(leftlangle m_x^2rightrangleright)\n\"Susceptibility y\"\nfracNTleft(leftlangle m_y^2rightrangleright)\n\"Susceptibility y\"\nfracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility x\"\nfracNTleft(leftlangle m_x^2rightrangle - leftlangle m_x rightrangle^2right)\n\"Connected Susceptibility y\"\nfracNTleft(leftlangle m_y^2rightrangle - leftlangle m_y rightrangle^2right)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{AshkinTeller, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::AshkinTeller, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, m is total magnetization per site and epsilon is total energy per site.\n\n\"Binder Ratio\"\nR = fracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility\"\nchi = fracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Binder Ratio sigma\"\nBinder ratio with respct to sigma\n\"Susceptibility sigma\"\nSusceptibility with respct to sigma\n\"Connected Susceptibility sigma\"\nConnected susceptibility with respct to sigma\n\"Binder Ratio tau\"\nBinder ratio with respct to tau\n\"Susceptibility tau\"\nSusceptibility with respct to tau\n\"Connected Susceptibility tau\"\nConnected susceptibility with respct to tau\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#SpinMonteCarlo.postproc-Tuple{QuantumXXZ, Dict{String, Any}, Dict{String, Obs} where Obs<:MCObservable}","page":"Internals","title":"SpinMonteCarlo.postproc","text":"postproc(model::QuantumXXZ, param::Parameter, obs::MCObservableSet)\n\nObservables to be calculated\n\nIn the following, s is sign of weight, m is total magnetization per site, and epsilon is total energy per site.\n\n\"Magnetization\"\nleftlangle m srightrangleBigleftlangle s rightrangle\n\"|Magnetization|\"\nleftlangle m srightrangleBigleftlangle s rightrangle\n\"Magnetization^2\"\nleftlangle m^2 srightrangleBigleftlangle s rightrangle\n\"Magnetization^4\"\nleftlangle m^4 srightrangleBigleftlangle s rightrangle\n\"Energy\"\nleftlangle epsilon srightrangleBigleftlangle s rightrangle\n\"Energy^2\"\nleftlangle epsilon^2 srightrangleBigleftlangle s rightrangle\n\"Binder Ratio\"\nfracleft langle m^4 right rangleleft langle m^2 rightrangle^2\n\"Susceptibility\"\nfracNTleft(leftlangle m^2rightrangleright)\n\"Connected Susceptibility\"\nfracNTleft(leftlangle m^2rightrangle - leftlangle m rightrangle^2right)\n\"Specific Heat\"\nfracNT^2left(leftlangle epsilon^2rightrangle - leftlangle epsilon rightrangle^2right)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Lattice","page":"Internals","title":"Lattice","text":"","category":"section"},{"location":"lib/internals/#SpinMonteCarlo.generatelattice","page":"Internals","title":"SpinMonteCarlo.generatelattice","text":"generatelattice(param::Parameter)\n\ngenerates Lattice from Parameter.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.numsitetypes","page":"Internals","title":"SpinMonteCarlo.numsitetypes","text":"numsitetypes(lat::Lattice)\nnumsitetypes(model::Model)\n\nReturns the number of sitetypes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.numbondtypes","page":"Internals","title":"SpinMonteCarlo.numbondtypes","text":"numbondtypes(lat::Lattice)\nnumbondtypes(model::Model)\n\nReturns the number of bondtypes.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Model","page":"Internals","title":"Model","text":"","category":"section"},{"location":"lib/internals/#SpinMonteCarlo.LoopElementType","page":"Internals","title":"SpinMonteCarlo.LoopElementType","text":"Enumtype including LET_*\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#SpinMonteCarlo.LET_Cut","page":"Internals","title":"SpinMonteCarlo.LET_Cut","text":"Loop element depicted as\n\n|\no\n|\n\nor matrix \n\n1 1 |+>\n1 1 |->\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#SpinMonteCarlo.LET_FMLink","page":"Internals","title":"SpinMonteCarlo.LET_FMLink","text":"Loop element depicted as\n\n|  |\n|--|\n|  |\n\nor matrix \n\n1 0 0 0 |++>\n0 0 0 0 |+->\n0 0 0 0 |-+>\n0 0 0 1 |-->\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#SpinMonteCarlo.LET_AFLink","page":"Internals","title":"SpinMonteCarlo.LET_AFLink","text":"Loop element depicted as\n\n|  |\n|~~|\n|  |\n\nor matrix \n\n0 0 0 0 |++>\n0 1 0 0 |+->\n0 0 1 0 |-+>\n0 0 0 0 |-->\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#SpinMonteCarlo.LET_Vertex","page":"Internals","title":"SpinMonteCarlo.LET_Vertex","text":"Loop element depicted as\n\n|  |\n~~~~\n~~~~\n|  |\n\nor matrix \n\n0 0 0 0 |++>\n0 1 1 0 |+->\n0 1 1 0 |-+>\n0 0 0 0 |-->\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#SpinMonteCarlo.LET_Cross","page":"Internals","title":"SpinMonteCarlo.LET_Cross","text":"Loop element depicted as\n\n|  |\n \\/\n /\\\n|  |\n\nor matrix \n\n1 0 0 0 |++>\n0 0 1 0 |+->\n0 1 0 0 |-+>\n0 0 0 1 |-->\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#SpinMonteCarlo.LocalLoopOperator","page":"Internals","title":"SpinMonteCarlo.LocalLoopOperator","text":"(Imaginary-temporary and spatial) local operator as a perturbation with assigned loop element.\n\nFields\n\nlet_type : assigned loop element\nisdiagonal : operator is diagonal or not\nin other words, two states connecting this perturbation are equivalent to each other or not.\ntime : imaginary time (taubeta in 01)) which this perturbation acts on.\nspace : spin or bond which this perturbation acts on.           denotes space spin if space <= nspins               or  space - nspins bond otherwise.\nsubspace : subspin(s) index\nbottom_id :: index of node of union find assigned to a loop\ntop_id :: index of node of union find assigned to the other loop\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"lib/internals/#SpinMonteCarlo.default_estimator","page":"Internals","title":"SpinMonteCarlo.default_estimator","text":"default_estimator(model, updatemethod!)\n\nDetermines estimator to be used when param[\"Estimator\"] is not set.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.@gen_convert_parameter","page":"Internals","title":"SpinMonteCarlo.@gen_convert_parameter","text":"@gen_convert_parameter(model_typename, (keyname, size_fn, default)...)\n\nGenerates convert_parameter(model::model_typename, param::Parameter).\n\nExample\n\n@gen_convert_parameter(A, (\"A\", numbondtypes, 1.0), (\"B\", 1, 1))\n\ngenerates a function equivalent to the following:\n\ndoc\"\"\"\n    convert_parameter(model::A, param::Parameter)\n\n# Keynames\n\n- \"A\": a vector with `numbondtypes(model)` elements (default: 1)\n- \"B\": a scalar (default: 1.0)\n\n\"\"\"\nfunction convert_parameter(model::A, param::Parameter)\n    ## if `size_fn` is a `Function`,\n    ## result is a vector whose size is `size_fn(model)`.\n    ## `param[\"A\"]` can take a scalar or a vector.\n    a = get(param, \"A\", 1.0)\n    as = zeros(Float64, numbondtypes(model))\n    as .= a\n\n    ## otherwise,\n    ## result is a scalar.\n    b = convert(Int, get(param, \"B\", 1))\n\n    return as, b\nend\n\n\n\n\n\n","category":"macro"},{"location":"lib/internals/#SpinMonteCarlo.SWInfo","page":"Internals","title":"SpinMonteCarlo.SWInfo","text":"Information of clusters in Swendsen-Wang algorithm.\n\nFields\n\nactivated_bonds : The number of activated (connected) bonds of each cluster.\nclustersize : The number of sites in each cluster.\nclusterspin : Spin variable of each cluster (e.g., 1 or -1 for Ising).\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#SpinMonteCarlo.UnionFind","page":"Internals","title":"SpinMonteCarlo.UnionFind","text":"Union-find algorithm.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#SpinMonteCarlo.addnode!","page":"Internals","title":"SpinMonteCarlo.addnode!","text":"addnode!(u::UnionFind)\n\nAdds a new node into u and returns the number of nodes including the added node.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.unify!","page":"Internals","title":"SpinMonteCarlo.unify!","text":"unify!(u, n1, n2)\n\nConnects n1 and n2 nodes using union by weight and returns the root.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.clusterize!","page":"Internals","title":"SpinMonteCarlo.clusterize!","text":"clusterize!(u::UnionFind)\n\nAssigns cluster ID to each node and returns the number of clusters.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.clusterid","page":"Internals","title":"SpinMonteCarlo.clusterid","text":"clusterid(u::UnionFind, i::Integer)\n\nReturns the index of the cluster where i node belongs.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.root!","page":"Internals","title":"SpinMonteCarlo.root!","text":"root!(u::UnionFind, n::Integer)\n\nReturns the root node of the cluster where n belongs. This may changes graph connection by \"Path halving\" method.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.root_path_halving!","page":"Internals","title":"SpinMonteCarlo.root_path_halving!","text":"root_path_halving!(u::UnionFind, n::Integer)\n\nReturns the root node of the cluster where n belongs. This may changes graph connection by \"Path halving\" method.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#SpinMonteCarlo.root_path_splitting!","page":"Internals","title":"SpinMonteCarlo.root_path_splitting!","text":"root_path_splitting!(u::UnionFind, n::Integer)\n\nReturns the root node of the cluster where n belongs. This may changes graph connection by \"Path splitting\" method.\n\n\n\n\n\n","category":"function"},{"location":"develop/#Develop-Monte-Carlo","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"","category":"section"},{"location":"develop/#Lattice","page":"Develop Monte Carlo","title":"Lattice","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"See src/lattice/standard.jl.","category":"page"},{"location":"develop/#Model","page":"Develop Monte Carlo","title":"Model","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"Model should contain following fields: lat :: Lattice and rng :: Random.MersenneTwister. Model also should have a constructor taking param :: Parameter as a argument.","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"You should define convert_parameter for your Model. This is a helper function which takes Model and Parameter and returns arguments of update method and estimator.","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"@gen_convert_parameter helps you to define convert_parameter. For example, if your model::A needs a scalar T = param[\"T\"] and a vector Js = param[\"J\"] with numbondtypes(model) elements,","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"@gen_convert_parameter(A, (\"T\", 1, 1.0), (\"J\", numbondtypes, 1.0))","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"defines your documented and type-stable  convert_parameter(model::A, param::Parameter) which returns T and Js.","category":"page"},{"location":"develop/#Note:","page":"Develop Monte Carlo","title":"Note:","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"That the second element of each tuple is not a Function means that a return value is a scalar (the case of \"T\").\nThe third element of each tuple is the default value.","category":"page"},{"location":"develop/#Update-method","page":"Develop Monte Carlo","title":"Update method","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"\"Update method\" is a function which (in-place) updates model::Model under some parameters such as temperature T. For example, local_update!(model::Ising, T, Js) updates a spin configuration of model by local spin flip and Metropolice-Hasting algorithm under temperature T and coupling constants Js. \"Update method\" can return some object which will be used in \"Estimator\" as extra information.","category":"page"},{"location":"develop/#Example","page":"Develop Monte Carlo","title":"Example","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"Swendsen-Wang algorithm SW_update!(::Ising, ::Parameter) returns cluster information sw::SWInfo used in improved_estimator.","category":"page"},{"location":"develop/#Estimator","page":"Develop Monte Carlo","title":"Estimator","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"\"Estimator\" is a function which returns observables of a configuration model as a Dict{String, Any}. Arguments of a \"Estimator\" are model::Model, parameters (return of convert_parameter), and extra information (return of \"Update method\") in order.","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"Default \"Estimator\" is determined by model and \"Update Method\" as return of default_estimator(model, param[\"Update Method\"]).","category":"page"},{"location":"develop/#Example-2","page":"Develop Monte Carlo","title":"Example","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"improved_estimator(model::Ising, T::Real, Js::AbstractArray, sw::SWInfo) takes a return of SW_update!(model::Ising, T::Real, Js::AbstractArray) as the last argument.","category":"page"},{"location":"develop/#Postprocess","page":"Develop Monte Carlo","title":"Postprocess","text":"","category":"section"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"postproc(model::Model, param::Parameter, obs::MCObservableSet) is a post process of a Monte Carlo run. Most important objective is to calculate functions of expectation values stored in obs.","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"For example, \"Specific Heat\" C can be calculated from \"Energy^2\" langle E^2rangle big N^2, \"Energy\" leftlangle Erightrangle big N, the number of site N, and temperature T as C = left(NbigT^2right)left leftlangle E^2 rightrangle - left langle E rightrangle^2 right. This is realized as","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"jk = jackknife(obs)\nT = param[\"T\"]\nN = numsites(model)\njk[\"Specific Heat\"] = (N/(T*T)) * (jk[\"Energy^2\"] - jk[\"Energy\"]^2)","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"jackknife converts MCObservableSet (e.g. BinningObservableSet) to JackknifeObservableSet, which enables to calculate functions of mean values and these statistical errors.","category":"page"},{"location":"develop/","page":"Develop Monte Carlo","title":"Develop Monte Carlo","text":"postproc returns a MCObservableSet (usually jk::JackknifeObservableSet above), which is also the return value of runMC.","category":"page"},{"location":"lattice/#Lattice","page":"Generate lattice","title":"Lattice","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"generatelattice(param::Parameter) generates a Lattice from the parameter.","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"\"Lattice\"\nThe name of the lattice\n\"L\"\nLength along each dimension","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"If you want to use a lattice/bravairs/unitcell you defined,  the following optional parameters must be set:","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"\"LatticeDict\"\n\"BravaisDict\"\n\"UnitcellDict\"","category":"page"},{"location":"lattice/#Pre-defined-lattices","page":"Generate lattice","title":"Pre-defined lattices","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"\"chain lattice\"\n\"bond-alternating chain lattice\"\n\"square lattice\"\n\"triangular lattice\"\n\"honeycomb lattice\"\n\"ladder\"\n\"cubic lattice\"\n\"fully connected lattice\"","category":"page"},{"location":"lattice/#Define-your-lattice","page":"Generate lattice","title":"Define your lattice","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"A lattice can be defined by combining a Bravais lattice (lattice basic vector) and a unit cell (sublattice structure). A lattice, a Bravais lattice, and a unit cell are represented by an instance of P = Dict{Symbol, Any}.","category":"page"},{"location":"lattice/#Lattice-2","page":"Generate lattice","title":"Lattice","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":":name => String\n:dimenstion => Integer\n:bravais => String\n:unitcell => String\n:parameters => Vector{Tuple{Symbol, Any}}\nTo overwrite the default value of parameters of a Bravais lattice\nAn element of a value is a tuple of parameter_name :: Symbol and new_default_value :: Any.\nex. [(:a, sqrt(3.0))]\n:periodic => Vector{Bool}\nTo specify the boundary condition (BC) for each dimension, periodic BC if true and open BC if false.","category":"page"},{"location":"lattice/#Bravais-lattice","page":"Generate lattice","title":"Bravais lattice","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":":name => String\n:dimension => Integer\n:parameters => Vector{Tuple{Symbol, Any}}\nparameter of the lattice vector\nAn element of a value is a tuple of parameter_name :: Symbol and default_value :: Any.\nex. [(:a, 1.0)]\n:basis => Expr\nparameterized lattice basic vector\nType of a value is Expr of an dim×dim Matrix\nex. :( [a 0.0; 0.0 a] )","category":"page"},{"location":"lattice/#Unit-cell","page":"Generate lattice","title":"Unit cell","text":"","category":"section"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":":name => String\n:dimension => Integer\n:sites => Vector{P}\n:bonds => Vector{P}","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"A site is an instance of Dict{Symbol, Any} having the following items:","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":":id => Integer\nThe site index in a unitcell (1-origin)\n:sitetype => Integer\nThe site type (1-origin)\n:coord => Vector{Float64}\nThe fractional coordinate of the site","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":"A bond is an instance of Dict{Symbol, Any} having the following items:","category":"page"},{"location":"lattice/","page":"Generate lattice","title":"Generate lattice","text":":bondtype => Integer\nThe bond type (1-origin)\n:source => P\nOne end (site) of a bond\nThe value is a P having the following items:\n:id => Integer : the site index in a unitcell\n:offset => Vector{Integer} : the coordinate of the unitcell\n:target => P\nAnother end (site) of a bond","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides Markov chain Monte Carlo solvers for lattice spin systems. Several models, lattices, and algorithms are already defined. Moreover, you can define your own model, lattice, and algorithm and combine with pre-defined ones.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpinMonteCarlo.jl is registered in the General registry.","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add SpinMonteCarlo","category":"page"},{"location":"#Simple-example","page":"Home","title":"Simple example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following simple example calculates and prints temperature dependence of specific heat for Ising model on a 16times16 square lattice by Swendsen-Wang algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SpinMonteCarlo\nusing Printf\n\nconst model = Ising\nconst lat = \"square lattice\"\nconst L = 16\nconst update! = SW_update!\n\nconst Tc = 2.0/log1p(sqrt(2))\nconst Ts = Tc*range(0.85, stop=1.15, length=31)\nconst MCS = 8192\nconst Therm = MCS >> 3\n\nfor T in Ts\n    param = Parameter(\"Model\"=>model, \"Lattice\"=>lat,\n                      \"L\"=>L, \"T\"=>T, \"J\"=>1.0,\n                      \"Update Method\"=>update!,\n                      \"MCS\"=>MCS, \"Thermalization\"=>Therm,\n                     )\n    result = runMC(param)\n    @printf(\"%f %.15f %.15f\\n\",\n            T, mean(result[\"Specific Heat\"]), stderror(result[\"Specific Heat\"])))\nend","category":"page"},{"location":"runmc/#Run-Monte-Carlo","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"","category":"section"},{"location":"runmc/#Overview","page":"Run Monte Carlo","title":"Overview","text":"","category":"section"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"runMC is a driver routine for a normal MCMC scheme having the following steps:","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"Initialization\nInitialize a model\nThermalization\nUpdate the spin configuration w/o measurement\nMeasurement\nUpdate the spin configuration w/  measurement","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"runMC takes a param :: Parameter and returns a MCMC result, jks ::JackknifeSet . param is a set of parameters. jks is a set of MCMC averaged quantities.","category":"page"},{"location":"runmc/#Input","page":"Run Monte Carlo","title":"Input","text":"","category":"section"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"param::Parameter is a mapping from keynames to values (Parameter is an alias of Dict{String, Any}). runMC requires the following parameters:","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"\"Model\"\ntypename of a model (ex. Ising)\n\"Lattice\"\nname of a lattice (ex. \"square lattice\")\n\"Update Method\"\nfunction to update a model (ex. local_update!)","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"The following are optional:","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"\"MCS\"\nThe number of Monte Carlo steps for measurement\ndefault: 8192\n\"Thermalization\"\nThe number of Monte Carlo steps for thermalization\ndefault: \"MCS\" >> 3\n\"Seed\"\nThe initial seed of the random number generator, Random.MersenneTwister\ndefault: random (see the doc of Random.seed!)\n\"Checkpoint Filename Prefix\"\nSuffix of filename of checkpoint file (see the \"Restart\" section)\ndefault: \"cp\"\n\"ID\"\nJob ID used for restarting\ndefault: 0\n\"Checkpoint Interval\"\nTime interval between saving a calculation state into the checkpoint file in units of second.\ndefault: 0.0, this means NO checkpoint files will be loaded and saved.\n\"Verbose\"\nprint message with the parameter before and after calculation\ndefault: false","category":"page"},{"location":"runmc/#Output","page":"Run Monte Carlo","title":"Output","text":"","category":"section"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"jks::JackknifeSet is a mapping from names to MCMC observables (JackknifeSet is an alias of Dict{String, Jackknife}). jk::Jackknife is a MCMC observable whose statistics are calculated by jack-knife method. Users can retrieve mean, variance, standard deviation, standard error, and p  confidence interval of jk by mean(jk), var(jk), stddev(jk), stderror(jk), and confidence_interval(jk, p/100), respectively.","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"The set of calculated quantities depends on the model (an estimator and a postproc). Please see the online document of specific functions (ex., simple_estimator(::Ising)).","category":"page"},{"location":"runmc/#Multiple-simulations","page":"Run Monte Carlo","title":"Multiple simulations","text":"","category":"section"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"runMC can take a list of parameters as an input instead of a single parameter and performs MCMC calculation for each parameter and returns a list of results. When a keyword arg parallel = true is passed, runMC performs MCMC calculations in parallel by using pmap function instead of map.","category":"page"},{"location":"runmc/#Restart","page":"Run Monte Carlo","title":"Restart","text":"","category":"section"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"If param[\"Checkpoint Interval\"] > 0.0, runMC saves the state of calculation (the state of the model and the random number generator) into a checkpoint file named \"$(param[\"Checkpoint Filename Prefix\"])_$(param[\"ID\"]).dat\" every param[\"Checkpoint Interval\"] seconds.","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"If a checkpoint file exists and param[\"Checkpoint Interval\"] > 0.0, runMC loads this file and restarts the pending simulation.","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"runMC(params::AbstractArray) has a keyword argument, autoID::Bool (default=true). If true, [\"ID\"] will be automatically set (overwritten) as params[i][\"ID\"] = i.","category":"page"},{"location":"runmc/","page":"Run Monte Carlo","title":"Run Monte Carlo","text":"NOTE: Restart will fail if the version or the system image of julia changes (see the doc of Serialization.serialize).","category":"page"},{"location":"lib/public/#Public-interfaces","page":"Public","title":"Public interfaces","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Documentation for SpinMonteCarlo.jl's public interface (exported).","category":"page"},{"location":"lib/public/#Driver","page":"Public","title":"Driver","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.runMC","page":"Public","title":"SpinMonteCarlo.runMC","text":"runMC(param::Parameter)\nrunMC(params::AbstractArray{Parameter}\n      ;\n      parallel::Bool=false,\n      autoID::Bool=true)\n\nRuns Monte Carlo simulation(s) and returns calculated observables.\n\nRestart\n\nIf a checkpoint file named \"$(param[\"Checkpoint Filename Prefix\"])_$(param[\"ID\"]).dat\" exists and param[\"Checkpoint Interval\"] > 0.0, runMC loads this file and restarts the pending simulation. NOTE: Restart will fail if the version or the system image of julia change (see the doc of Serialization.serialize ).\n\nKeyward arguments\n\nautoID: If true, \"ID\"s will be set (overwritten) as params[i][\"ID\"] = i.\nparallel: If true, runs simulations in parallel (uses pmap instead of map).\n\nRequired keys in param\n\n\"Model\"\n\"Lattice\"\n\"Update Method\"\n\nOptional keys in param\n\n\"MCS\": The number of Monte Carlo steps after thermalization\nDefault: 8192\n\"Thermalization\": The number of Monte Carlo steps for thermalization\nDefault: MCS>>3\n\"Binning Size\": The size of binning\nDefault: 0\n\"Number of Bins\": The number of bins\nDefault: 0\nIf both \"Binning Size\" and \"Number of Bins\" are not given, \"Binning Size\" is set to floor(sqrt(MCS)).\n\"Seed\": The initial seed of the random number generator, MersenneTwister\nDefault: determined randomly (see the doc of Random.seed!)\n\"Checkpoint Filename Prefix\": See the \"Restart\" section.\nDefault: \"cp\"\n\"ID\": See the \"Restart\" section.\nDefault: 0\n\"Checkpoint Interval\": Time interval between writing checkpoint file in seconds.\nDefault: 0.0, this means that NO checkpoint file will be loaded and saved.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Lattice","page":"Public","title":"Lattice","text":"","category":"section"},{"location":"lib/public/#PDMats.dim","page":"Public","title":"PDMats.dim","text":"dim(lat::Lattice)\ndim(model::Model)\n\nReturns the dimension of lattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Base.size","page":"Public","title":"Base.size","text":"size(lat::Lattice, [dim::Integer])\nsize(model::Model, [dim::Integer])\n\nReturns the size of lattice.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.sites","page":"Public","title":"SpinMonteCarlo.sites","text":"sites(lat::Lattice, [sitetype::Integer])\nsites(model::Model, [sitetype::Integer])\n\nReturns an iterator over sites with sitetype (if omitted, over all sites)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.bonds","page":"Public","title":"SpinMonteCarlo.bonds","text":"bonds(lat::Lattice, [bondtype::Integer])\nbonds(model::Model, [bondtype::Integer])\n\nReturns an iterator over bonds with bondtype (if omitted, over all bonds)\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.numsites","page":"Public","title":"SpinMonteCarlo.numsites","text":"numsites(lat::Lattice)\nnumsites(model::Model)\n\nReturns the number of all sites.\n\n\n\n\n\nnumsites(lat::Lattice, sitetype::Integer)\nnumsites(model::Model, sitetype::Integer)\n\nReturns the number of sitetype sites.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.numbonds","page":"Public","title":"SpinMonteCarlo.numbonds","text":"numbonds(lat::Lattice)\nnumbonds(model::Model)\n\nReturns the number of all bonds.\n\n\n\n\n\nnumbonds(lat::Lattice, bondtype::Integer)\nnumbonds(model::Model, bondtype::Integer)\n\nReturns the number of bondtype bonds.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.neighbors","page":"Public","title":"SpinMonteCarlo.neighbors","text":"neighbors(site::Site)\nneighbors(lat::Lattice, site::Integer)\nneighbors(model::Model, site::Integer)\n\nReturns the index pairs of neighbor sites and bonds of site.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.neighborsites","page":"Public","title":"SpinMonteCarlo.neighborsites","text":"neighborsites(site::Site)\nneighborsites(lat::Lattice, site::Integer)\nneighborsites(model::Model, site::Integer)\n\nReturns the indecies of neighbor sites of site.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.neighborbonds","page":"Public","title":"SpinMonteCarlo.neighborbonds","text":"neighborbonds(site::Site)\nneighborbonds(lat::Lattice, site::Integer)\nneighborbonds(model::Model, site::Integer)\n\nReturns the indecies of neighbor bonds of site.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.source","page":"Public","title":"SpinMonteCarlo.source","text":"source(bond::Bond)\nsource(lat::Lattice, bond::Integer)\nsource(model::Model, bond::Integer)\n\nReturns the source site index of bond.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.target","page":"Public","title":"SpinMonteCarlo.target","text":"target(bond::Bond)\ntarget(lat::Lattice, bond::Integer)\ntarget(model::Model, bond::Integer)\n\nReturns the target site of bond.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.sitetype","page":"Public","title":"SpinMonteCarlo.sitetype","text":"sitetype(site::Site)\nsitetype(lat::Lattice, site::Integer)\nsitetype(model::Model, site::Integer)\n\nReturns the type of site\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.bondtype","page":"Public","title":"SpinMonteCarlo.bondtype","text":"bondtype(bond::Bond)\nbondtype(lat::Lattice, bond::Integer)\nbondtype(model::Model, bond::Integer)\n\nReturns the type of bond.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.sitecoordinate","page":"Public","title":"SpinMonteCarlo.sitecoordinate","text":"sitecoordinate(site::Site)\nsitecoordinate(lat::Lattice, site::Integer)\nsitecoordinate(model::Model, site::Integer)\n\nReturns the coordinate of the site in the Cartesian system\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.bonddirection","page":"Public","title":"SpinMonteCarlo.bonddirection","text":"bonddirection(bond::Bond)\nbonddirection(lat::Lattice, bond::Integer)\nbonddirection(model::Model, bond::Integer)\n\nReturns the unnormalized direction of the bond as vector in the Cartesian system\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.cellcoordinate","page":"Public","title":"SpinMonteCarlo.cellcoordinate","text":"cellcoordinate(site::Site)\ncellcoordinate(lat::Lattice, site::Integer)\ncellcoordinate(model::Model, site::Integer)\n\nReturns the coordinate of the cell including site in the Lattice system\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Model","page":"Public","title":"Model","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.Ising","page":"Public","title":"SpinMonteCarlo.Ising","text":"Ising model with energy E = -sum_ij J_ij sigma_i sigma_j, where sigma_i takes value of 1 (up spin) or -1 (down spin).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.Potts","page":"Public","title":"SpinMonteCarlo.Potts","text":"Q state Potts model with energy E = -sum_ij delta_sigma_i sigma_j, where sigma_i takes an integer value from 1 to Q and delta is a Kronecker's delta. Order parameter (total magnetization) is defined as \\begin{equation}     M = \\frac{Q-1}{Q}N1 - \\frac{1}{Q}(N-N1), \\end{equation} where N is the number of sites and N_1 is the number of sigma=1 spins.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.Clock","page":"Public","title":"SpinMonteCarlo.Clock","text":"Q state clock model with energy E = -sum_ij J_ij cos(theta_i - theta_j), where theta_i = 2pi sigma_iQ and sigma_i takes an integer value from 1 to Q.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.XY","page":"Public","title":"SpinMonteCarlo.XY","text":"XY model with energy E = -sum_ij J_ij cos(theta_i - theta_j), where theta_i = 2pi sigma_i and sigma_i in 0 1).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.AshkinTeller","page":"Public","title":"SpinMonteCarlo.AshkinTeller","text":"AshkinTeller model with energy E = -sum_ij J^sigma_ij sigma_i sigma_j + J^tau_ij tau_i tau_j + K_ij sigma_i sigma_j tau_i tau_j, where sigma_i and tau_i takes value of 1 (up spin) or -1 (down spin).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.QuantumXXZ","page":"Public","title":"SpinMonteCarlo.QuantumXXZ","text":"Spin-S XXZ model represented as the following Hamiltonian,\n\nmathcalH = sum_ij left J_ij^z S_i^z S_j^z              + fracJ_ij^xy2 (S_i^+ S_j^- + S_i^-S_j^+) right             - sum_i Gamma_i S_i^x\n\nwhere S^x S^y S^z are x y and z component of spin operator with length S, and S^pm equiv S^x pm iS^y are ladder operator. A state is represented by a product state (spins at tau=0) of local S^z diagonal basis and an operator string (perturbations). A local spin with length S is represented by a symmetrical summation of 2S sub spins with length 12.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Update-method","page":"Public","title":"Update method","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"An index of model parameter (e.g., Js) is corresponding to sitetype or bondtype.","category":"page"},{"location":"lib/public/#SpinMonteCarlo.local_update!","page":"Public","title":"SpinMonteCarlo.local_update!","text":"local_update!(model, param)\n\nUpdates spin configuration by local spin flip and Metropolice algorithm \n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.SW_update!","page":"Public","title":"SpinMonteCarlo.SW_update!","text":"SW_update!(model, param::Parameter)\n\nUpdates spin configuration by Swendsen-Wang algorithm\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.Wolff_update!","page":"Public","title":"SpinMonteCarlo.Wolff_update!","text":"Wolff_update!(model, param::Parameter)\n\nUpdates spin configuration by Wolff algorithm\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.loop_update!","page":"Public","title":"SpinMonteCarlo.loop_update!","text":"loop_update!(model, param::Parameter)\n\nUpdates spin configuration by loop algorithm \n\n\n\n\n\nloop_update!(model, param::Parameter)\nloop_update!(model, T::Real,\n             Jz::AbstractArray,\n             Jxy::AbstractArray,\n             Gamma:AbstractArray)\n\nUpdates spin configuration by loop algorithm  under the temperature T = param[\"T\"] and coupling constants Jz, Jxy and transverse field Gamma\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Estimator","page":"Public","title":"Estimator","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.simple_estimator","page":"Public","title":"SpinMonteCarlo.simple_estimator","text":"simple_estimator(model::Ising, T::Real, Js::AbstractArray)\n\nReturns the following observables as Dict{String, Any}\n\nObservables\n\n\"Energy\"\nenergy density\n\"Energy^2\"\nsquare of energy density\n\"Magnetization\"\nmagnetization density\n\"|Magnetization|\"\nabsolute value of magnetization density\n\"Magnetization^2\"\nsquare of magnetization density\n\"Magnetization^4\"\nquadruple of magnetization density\n\n\n\n\n\nsimple_estimator(model::Clock, T::Real, Js::AbstractArray)\nsimple_estimator(model::XY, T::Real, Js::AbstractArray)\n\nReturns the following observables as Dict{String, Any}\n\nObservables\n\n\"Energy\"\nEnergy per spin (site)\n\"Energy^2\"\n\"|Magnetization|\"\nAbsolute value of total magnetization per spin (order paremeter)\n\"|Magnetization|^2\"\n\"|Magnetization|^4\"\n\"Magnetization x\"\nx component of total magnetization per spin (order paremeter)\n\"|Magnetization x|\"\n\"Magnetization x^2\"\n\"Magnetization x^4\"\n\"Magnetization y\"\ny component of total magnetization per spin (order paremeter)\n\"|Magnetization y|\"\n\"Magnetization y^2\"\n\"Magnetization y^4\"\n\"Helicity Modulus x\"\n\"Helicity Modulus y\"\n\n\n\n\n\nsimple_estimator(model::AshkinTeller, T::Real, Jsigma, Jtau, K)\n\nReturns the following observables as Dict{String, Any}\n\nObservables\n\n\"Energy\"\nenergy density\n\"Energy^2\"\nsquare of energy density\n\"|Magnetization|\"\nabsolute value of magnetization density, m = sqrt (sum_i sigma_i )^2 + (sum_i tau_i)^2   N\n\"|Magnetization|^2\"\nsquare of magnetization density\n\"|Magnetization|^4\"\nquadruple of magnetization density\n\"Magnetization sigma\"\nmagnetization density (sigma spin)\n\"|Magnetization sigma|\"\n\"Magnetization sigma^2\"\n\"Magnetization sigma^4\"\n\"Magnetization tau\"\nmagnetization density (tau spin)\n\"|Magnetization tau|\"\n\"Magnetization tau^2\"\n\"Magnetization tau^4\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.improved_estimator","page":"Public","title":"SpinMonteCarlo.improved_estimator","text":"improved_estimator(model::Ising, T::Real, Js::AbstractArray, sw::SWInfo)\n\nReturns the following observables as Dict{String, Any} using cluster information sw\n\nObservables\n\n\"Energy\"\nenergy density\n\"Energy^2\"\nsquare of energy density\n\"Magnetization\"\nmagnetization density\n\"|Magnetization|\"\nabsolute value of magnetization density\n\"Magnetization^2\"\nsquare of magnetization density\n\"Magnetization^4\"\nquadruple of magnetization density\n\"Clustersize^2\"\nsum_c r_c^2, where r_c is the size density of c-th cluster\n\"Clustersize^4\"\nsum_c r_c^4\n\"Clustersize^2 Clustersize^2\"\nsum_cne c r_c^2 r_c^2\n\n\n\n\n\nimproved_estimator(model::Potts, T::Real, Js::AbstractArray, sw::SWInfo)\n\nReturns the following observables as Dict{String, Any} using cluster information sw\n\nObservables\n\n\"Energy\"\nenergy density\n\"Energy^2\"\nsquare of energy density\n\"Magnetization\"\nmagnetization density\n\"|Magnetization|\"\nabsolute value of magnetization density\n\"|Magnetization|^2\"\nsquare of magnetization density\n\"|Magnetization|^4\"\nquadruple of magnetization density\n\"Clustersize^2\"\nsum_c r_c^2, where r_c is the size density of c-th cluster\n\"Clustersize^4\"\nsum_c r_c^4\n\"Clustersize^2 Clustersize^2\"\nsum_cne c r_c^2 r_c^2\n\n\n\n\n\nimproved_estimator(model::QuantumXXZ, T::Real, Js::AbstractArray, uf::UnionFind)\n\nReturns the following observables as Dict{String, Any} using loop information uf\n\nObservables\n\n\"Sign\"\nSign of the weight function\n\"Sign * Energy\"\nEnergy per spin (site)\n\"Sign * Energy^2\"\n\"Sign * Magnetization\"\nTotal magnetization (Sz) per spin (site)\n\"Sign * |Magnetization|\"\n\"Sign * Magnetization^2\"\n\"Sign * Magnetization^4\"\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Observables","page":"Public","title":"Observables","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.MCObservable","page":"Public","title":"SpinMonteCarlo.MCObservable","text":"MCObservable\n\nabstract type representing observable in Monte Carlo calculation.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.ScalarObservable","page":"Public","title":"SpinMonteCarlo.ScalarObservable","text":"ScalarObservable <: MCObservable\n\nabstract type representing scalar-type observable in Monte Carlo calculation.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.VectorObservable","page":"Public","title":"SpinMonteCarlo.VectorObservable","text":"VectorObservable <: MCObservable\n\nabstract type representing vector-type observable in Monte Carlo calculation.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.MCObservableSet","page":"Public","title":"SpinMonteCarlo.MCObservableSet","text":"MCObservableSet{Obs}\n\nAlias of `Dict{String, Obs}` where `Obs` is a subtype of `MCObservable`.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.makeMCObservable!","page":"Public","title":"SpinMonteCarlo.makeMCObservable!","text":"makeMCObservable!(oset::MCObservableSet{Obs}, name::String)\n\nCreate an observable with the name `name` in the observable set `oset`.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.SimpleObservable","page":"Public","title":"SpinMonteCarlo.SimpleObservable","text":"SimpleObservable\n\nA simple observable which stores all the data in memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.SimpleVectorObservable","page":"Public","title":"SpinMonteCarlo.SimpleVectorObservable","text":"SimpleVectorObservable\n\nA simple observable which stores all the data in memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.SimpleObservableSet","page":"Public","title":"SpinMonteCarlo.SimpleObservableSet","text":"SimpleObservableSet\n\nAlias of `MCObservableSet{SimpleObservable}`.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.SimpleVectorObservableSet","page":"Public","title":"SpinMonteCarlo.SimpleVectorObservableSet","text":"SimpleObservableSet\n\nAlias of `MCObservableSet{SimpleVectorObservable}`.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.binning","page":"Public","title":"SpinMonteCarlo.binning","text":"binning(obs::SimpleObservable; binsize::Int = 0, numbins::Int = 0)\nbinning(obs::SimpleVectorObservable; binsize::Int = 0, numbins::Int = 0)\n\nBinning the observable `obs`.\nEither `binsize` or `numbins` can be given. If both are given, `ArgumentError` is thrown.\nIf both are not given, `binsize` is set to `floor(sqrt(count(obs)))`.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.Jackknife","page":"Public","title":"SpinMonteCarlo.Jackknife","text":"Jackknife <: ScalarObservable\n\nJackknife resampling observable.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.JackknifeVector","page":"Public","title":"SpinMonteCarlo.JackknifeVector","text":"JackknifeVector <: VectorObservable\n\nJackknife resampling observable for vector-type observable.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.JackknifeSet","page":"Public","title":"SpinMonteCarlo.JackknifeSet","text":"JackknifeSet\n\nAlias of `MCObservableSet{Jackknife}`.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.JackknifeVectorSet","page":"Public","title":"SpinMonteCarlo.JackknifeVectorSet","text":"JackknifeVectorSet\n\nAlias of `MCObservableSet{JackknifeVector}`.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.jackknife","page":"Public","title":"SpinMonteCarlo.jackknife","text":"jackknife(obs::ScalarObservable)\n\nConstruct a Jackknife observable from a scalar observable\n\n\n\n\n\njackknife(obsset::MCObservableSet)\n\nConstruct a JackknifeSet from a MCObservableSet\n\n\n\n\n\njackknife(obs::VectorObservable)\n\nConstruct a JackknifeVector observable from a vector observable\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Snapshots","page":"Public","title":"Snapshots","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.gen_snapshot!","page":"Public","title":"SpinMonteCarlo.gen_snapshot!","text":"gen_snapshot!(model, T, [N=1])\n\ngenerate and return N snapshots (spin configuration).\n\nArguments\n\nmodel::Model : model\nT::Real : temperature\nN::Integer=1 : the number of snapshots to be generated\nMCS::Integer=8192 : the number of Monte Carlo steps followed by snapshot generation\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.gensave_snapshot!","page":"Public","title":"SpinMonteCarlo.gensave_snapshot!","text":"gensave_snapshot!(io, model, T, [N=1])\ngensave_snapshot!(filename, model, T, [N=1])\n\ngenerate and write N snapshots into io or filename.\n\nArguments\n\nio::IO : output stream where snapshots will be written\nfilename::String : the name of file where snapshots will be written\nmodel::Model : model to be simulated\nT::Real : temperature\nN::Integer=1 : the number of snapshots to be generated\nMCS::Integer=1 : the number of Monte Carlo steps followed by snapshot generation\nsep::String=\" \" : field separator of snapshot\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.load_snapshot","page":"Public","title":"SpinMonteCarlo.load_snapshot","text":"load_snapshot(io, splitter)\nload_snapshot(filename, splitter)\n\nload snapshot from io or filename. splitter is the set of field splitter and will be passed Base.split as the second argument (see the doc of Base.split).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Utility","page":"Public","title":"Utility","text":"","category":"section"},{"location":"lib/public/#SpinMonteCarlo.Parameter","page":"Public","title":"SpinMonteCarlo.Parameter","text":"Input parameter of simulation\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model, param)\n\nGenerates arguments of updater and estimator.\n\nExample\n\njulia> model = Ising(chain_lattice(4));\n\njulia> p = convert_parameter(model, Parameter(\"J\"=>1.0))\n(1.0, [1.0, 1.0]) # T and Js\n\njulia> p = convert_parameter(model, Parameter(\"J\"=>[1.5, 0.5]))\n(1.0, [1.5, 0.5]) # J can take a vector whose size is `numbondtypes(model)`\n\njulia> model.spins\n4-element Array{Int64,1}:\n  1\n  1\n  1\n -1\n\njulia> local_update!(model, p...);\n\njulia> model.spins\n4-element Array{Int64,1}:\n  1\n  1\n -1\n -1\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{Ising, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::Ising, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"J\": a vector with numbondtypes(model) elements (default: 1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{Potts, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::Potts, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"J\": a vector with numbondtypes(model) elements (default: 1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{Clock, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::Clock, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"J\": a vector with numbondtypes(model) elements (default: 1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{XY, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::XY, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"J\": a vector with numbondtypes(model) elements (default: 1.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{AshkinTeller, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::AshkinTeller, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"Jsigma\": a vector with numbondtypes(model) elements (default: 1.0).\n\"Jtau\": a vector with numbondtypes(model) elements (default: 1.0).\n\"K\": a vector with numbondtypes(model) elements (default: 0.0).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#SpinMonteCarlo.convert_parameter-Tuple{QuantumXXZ, Dict{String, Any}}","page":"Public","title":"SpinMonteCarlo.convert_parameter","text":"convert_parameter(model::QuantumXXZ, param::Parameter)\n\nKeynames:\n\n\"T\": a scalar (default: 1.0).\n\"Jz\": a vector with numbondtypes(model) elements (default: 1.0).\n\"Jxy\": a vector with numbondtypes(model) elements (default: 1.0).\n\"Gamma\": a vector with numsitetypes(model) elements (default: 0.0).\n\n\n\n\n\n","category":"method"}]
}
